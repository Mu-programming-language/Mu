Helpers
	lower_case = ['a'..'z'];
	upper_case = ['A'..'Z'];
	letter = lower_case | upper_case;
	digit = ['0'..'9'];
	space = ' ';
	tab = 9;
	lf = 10;
	cr = 13;
	all = [0..0xFFFF];
	eol = cr lf | cr | lf;
	blank = (space | tab | eol);
	all_except_eol = [all - [cr + lf]];
	not_star =    [all - '*'] | eol;
    not_star_not_slash = [all - ['*' + '/']] | eol;
	all_except_double_quote = [all - '"'];

Tokens
	category = 'analysis' | 'algebra' | 'set theory' | 'geometry' | 'statistic and probability';

	proof = 'Proof';
	statement = 'Statement';
	question = 'Question';

	let = 'let';
	done = 'done';
	show = 'show';

	deprived_of = '\';

	not = '¬' /*| 'not'*/;

	empty_set = '∅';

	multiplication = '*';
	division = '/';
	modulo = '%';
	plus = '+';
	minus = '-';
	power = '^';

	for_all = '∀' /*| 'forall'*/;
	exist = '∃' /*| 'exists'*/;

	such_as = '|' /*| 'suchas'*/;
	comma = ',';
	semicolon = ';';
	column = ':';
	diesis = '#';
	implication_sign = '=>';
	equivalence_sign = '<=>';

	logical_and = '∧' /*| 'and'*/;
	logical_or = '∨' /*| 'or'*/;

	union = '∪' /*| 'union'*/;
	intersection = '∩' /*| 'intersection'*/;

	subset_of = '⊂' /*| 'subsetof'*/;
	superset_of = '⊃' /*| 'supersetof'*/;
	not_a_subset_of = '⊄';
	not_a_superset_of = '⊅';

	element_of = '∈' /*| 'elementof'*/;
	contains_as_member = '∋' /*| 'containsasmember'*/;
	not_an_element_of = '∉';
	does_not_contain_as_member = '∌';

	left_brace = '{';
	right_brace = '}';
	left_parenthesis = '(';
	right_parenthesis = ')';
	lelft_bracket = '[';
	right_bracket = ']';

	equal_to = '=';
	greater_than = '>';
	less_than = '<';
	greater_than_or_equal_to = '≥' | '>=';
	less_than_or_equal_to = '≤' | '<=';
	not_equal_to = '≠' | '!=';
	not_greater_than = '≯' | '!>';
	not_less_than = '≮' | '!<';
	neither_greater_than_nor_equal_to = '≱' | '!>=';
	neither_less_than_nor_equal_to = '≰' | '!<=';

	tag_number = '#' digit+ letter?;

	number = '0' | (['1'..'9'] digit*);

	set_identifier = upper_case;
	element_identifier = lower_case;

	string = '"' all_except_double_quote* '"';

	blank = blank+;
	short_comment = '//' all_except_eol* eol?;
	long_comment = '/*' not_star+ '*'+ (not_star_not_slash not_star* '*'+)* '/';

Ignored Tokens
	blank,
	short_comment,
	long_comment;

Productions
	program =
		category semicolon instructions;
	instructions =
		statement_block question_block proof_block;
	statement_block =
		statement column statement_instruction_list;
	question_block =
		question column question_instruction_list;
	proof_block =
		proof column proof_instruction_list;
	statement_instruction_list =
		statement_instruction additional_statement_instruction* semicolon;
	additional_statement_instruction =
		comma statement_instruction;
	statement_instruction =
		{declaration} let set_identifier |
		{assignment} [new]:set_identifier equal_to left_brace element_identifier element_of set_identifier such_as element_expression right_brace |
		{definition} let [new]:set_identifier equal_to left_brace element_identifier element_of set_identifier such_as element_expression right_brace;
	question_instruction_list =
		question_instruction additional_question_instruction* semicolon;
	additional_question_instruction =
		comma question_instruction;
	question_instruction =
		tag_number column show set_expression;
	proof_instruction_list =
		proof_instruction additional_proof_instruction*;
	additional_proof_instruction =
		proof_instruction;
	proof_instruction =
		tag_number column demonstration done semicolon;

	demonstration =
		proposition_list+;
	proposition_list =
		proposition additional_proposition* semicolon;
	additional_proposition =
		{implication} implication_sign proposition |
		{equivalence} equivalence_sign proposition;
	proposition =
		{expression} expression |
		{for_all} for_all element_identifier element_of set_identifier comma expression |
		{exist} exist element_identifier element_of set_identifier comma expression;

	expression =
		{expression} element_expression element_of set_expression |
		{set_expression} set_expression |
		{element_expression} element_expression;

	set_expression =
		{comparison} set_comparison |
		{logical_and} set_expression logical_and set_comparison |
		{logical_or} set_expression logical_or set_comparison;
	set_comparison =
		{arithmetic} set_arithmetic |
		{equal_to} set_comparison equal_to set_arithmetic |
		{not_equal_to} set_comparison not_equal_to set_arithmetic |
		{subset_of} set_comparison subset_of set_arithmetic |
		{not_a_subset_of} set_comparison not_a_subset_of set_arithmetic |
		{superset_of} set_comparison superset_of set_arithmetic |
		{not_a_superset_of} set_comparison not_a_superset_of set_arithmetic;
	set_arithmetic =
		{factor} set_factor |
		{plus} set_arithmetic plus set_factor |
		{deprived_of} set_arithmetic deprived_of set_factor;
	set_factor =
		{term} set_exponent |
		{mult} set_factor multiplication set_exponent;
	set_exponent =
		{term} set_term |
		{exp} set_exponent power set_term;
	set_term =
		{set} set_identifier |
		{expression} left_parenthesis set_expression right_parenthesis;

	element_expression =
		{comparison} element_comparison |
		{logical_and} element_expression logical_and element_comparison |
		{logical_or} element_expression logical_or element_comparison;
	element_comparison =
		{arithmetic} element_arithmetic |
		{equal_to} element_comparison equal_to element_arithmetic |
		{not_equal_to} element_comparison not_equal_to element_arithmetic |
		{greater_than} element_comparison greater_than element_arithmetic |
		{not_greater_than} element_comparison not_greater_than element_arithmetic |
		{less_than} element_comparison less_than element_arithmetic |
		{not_less_than} element_comparison not_less_than element_arithmetic |
		{greater_than_or_equal_to} element_comparison greater_than_or_equal_to element_arithmetic |
		{neither_greater_than_nor_equal_to} element_comparison neither_greater_than_nor_equal_to element_arithmetic |
		{less_than_or_equal_to} element_comparison less_than_or_equal_to element_arithmetic |
		{neither_less_than_nor_equal_to} element_comparison neither_less_than_nor_equal_to element_arithmetic;
	element_arithmetic =
		{factor} element_factor |
		{plus} element_arithmetic plus element_factor |
		{minus} element_arithmetic minus element_factor;
	element_factor =
		{term} element_term |
		{multiplication} element_factor multiplication element_term |
		{division} element_factor division element_term |
		{modulo} element_factor modulo element_term;
	element_term =
		{number} number |
		{element} element_identifier |
		{expression} left_parenthesis element_expression right_parenthesis;
